### Задача up05-7: c++/inheritance/copters-1

По случаю победы хряка Наполеона в конкурсе красоты решено устроить
красочное шоу ~~с блекджеком~~ с хай-теком и полетухами. Одним из
элементов шоу будет построение разных фигур из летящих квадрокоптеров.

Хряк Рогожка, который пообещал, что ~~супер~~зверокоптеры, разработанные
под его руководством, будут превосходить по всем показателям
квадрокоптеры с соседней фермы, предоставил зверокоптер со следующими
характеристиками: зверокоптер может перемещаться только в четырех
направлениях: влево, вправо, вверх и вниз на 1 условную единицу (клетку)
за ход. Зверокоптер обладает оперативной памятью размером 10 байт. Но
главной инновацией при разработке зверокоптера было оснащение его
средствами NFC (near-field communication), благодаря которым,
зверокоптер может считывать состояние памяти зверокоптеров, находящихся
рядом с ним.

Во все зверокоптеры загружается одинаковая программа, которая на каждом
шаге анализирует состояние памяти своего зверокоптеров и соседних
зверокоптеров и выдает команду на перемещение зверокоптера. Будем
предполагать, что все зверокоптеры сначала считывают состояние памяти
друг друга, а затем одномоментно устанавливают новое состояние памяти и
перемещаются.

Ваша задача - написать программу для зверокоптера, которая по текущему
состоянию зверокоптера и его соседей построит заданную фигуру.

Представим поле в виде прямоугольной сетки, в некоторых клетках которой
находятся зверокоптеры. Изначально они находятся в неизвестных различных
координатах, но гарантируется что начальная конфигурация является
связной по сторонам фигурой. В процессе перемещения несколько
зверокоптеров могут размещаться в одной клетке.

При формировании фигуры зверокоптерами важно только относительное
положение зверокоптеров относительно друг-друга. То есть требуется чтобы
в какой-то момент времени относительная конфигурация должна совпадать с
заданной.

Для программирования зверокоптера вам необходимо написать класс,
реализующий интерфейс `CopterStrategy`. Выполнение очередного хода
зверокоптером выполняется следующим образом: объект класса
`CopterStrategy` создается без аргументов с помощью фабрики классов (см.
ниже). Затем у вашего класса вызывается метод `set_copter_count`, с
помощью которого задается общее число зверокоптеров. Затем для каждого
зверокоптера (зверокоптеры нумеруются от 0 подряд) вызывается метод
`set_target_pos`, задающий относительную позицию на карте, в которую
должен оказаться зверокоптер.

Затем для вашего зверокоптера вызывается метод `set_memory`,
устанавливающий состояние памяти текущего зверокоптера. Зверокоптер
должен хранить как минимум `MEMORY_SIZE` байт памяти. Если значение
аргумента меньше, остаток дополняется нулями, если значение аргумента
больше, зверокоптер может не помещающиеся элементы проигнорировать.

Далее вызывается метод `set_neighbour_count`, который задает количество
зверокоптеров, соседних с заданным зверокоптером, то есть зверокоптеров,
находящихся на одну клетку левее, правее, выши или ниже данного или в
одной с ним клетке. Соседние зверокоптеры нумеруются от 0 и подряд.
Соответствие номеров соседних зверокоптеров и целевых позиций
зверокоптеров неизвестно и может меняться на каждом ходе. Далее для
каждого зверокоптера вызывается метод `set_neighbour_dir`, задающий
позицию зверокоптера относительно текущего, то есть `Direction::LEFT`
означает, что этот зверокоптер находится на одну клетку левее текущего,
а `Direction::STAY` означает, что этот зверокоптер находится в одной
клетке с текущим. Далее вызывается метод `set_neighbour_memory`,
задающий состояние памяти указанного зверокоптера.

После вызова всех методов, задающих текущую конфигурацию зверокоптера,
вызывается метод `compute_move`, после чего с помощью методов `get_dir`
и `get_memory` считывается новое состояние квадрокоптера. Метод
`get_dir` задает, в каком направлении должен двигаться зверокоптер, то
есть `Direction::LEFT` означает, что зверокоптер должен сместиться на
одну клетку влево, а `Direction::STAY` означает, что зверокоптер должен
остаться на месте.

Метод `get_memory` копирует новое состояние памяти по указанному адресу.
Если переданный размер `size` меньше размера памяти квадрокоптера, то
копируется только начальная часть памяти, а если переданный размер
больше, то копируется вся память, а остаток заполняется нулями.

Чтобы в процессе работы программы можно было создавать новые объекты
вашего класса, отнаследованного от `CopterStrategy`, вам нужно
реализовать фабрику классов, унаследованную от `CopterStrategyFactory`.

Чтобы зарегистрировать вашу фабрику классов используйте метод
`register_strategy` у класса-синглтона `CopterStrategyFactoryManager`.
Вам не нужно сдавать на проверку реализацию
`CopterStrategyFactoryManager`.

Вы можете использовать следующие файлы: [`copterstrategy.h`](copterstrategy.h),
[`copterstrategyfactorymanager.cpp`](copterstrategyfactorymanager.cpp). Они будут доступны при компиляции
вашего класса.

### Сдать решение
